> 计算机网络<参考 计算机网络:自顶向下>
>
> 参考博客链接:
>
> 1. <https://www.jianshu.com/p/b3cbddac480c>
> 2. <https://www.jianshu.com/p/8666237e5ddd>
> 3. <https://www.jianshu.com/p/674fb7ec1e2c>
> 4. <https://www.cnblogs.com/inception6-lxc/p/9152691.html>
>
> 仅针对技术面试!!!! 
>
> 如果您不是为了招聘而准备计算机网络的相关知识 , 强烈建议您认真的跟随  (计算机网络:自顶向下 )学习.

[TOC]



# TCP/UDP

> 这是面试中最为常见的几个计算机网络的题目之一  , 在给出答案之前 , 需要了解的预备知识
>
> #TCP / UDP 都是运行在传输层的协议 
>
> #传输层协议为不同主机的进程提供逻辑通信 , 所以区别主要针对进程而言

[TCP介绍](https://baijiahao.baidu.com/s?id=1638084913643758145&wfr=spider&for=pc):

> 先别急着立刻搞清楚概念 , 要先介绍几个常见缩写的含义:
>
> ACK:主机收到发送端消息后 , 返回一个已收到消息的通知 , 叫做确认应答. , 为 1 时才为有效的应答
>
> SEQ:当数据比较大时 , 通常会将其切割成分组 , 给分组分配的序列号.
>
> SYN:同步序列编号 , 表示建立连接 , 在三次握手时常见 , 请记住
>
> FIN:表示关闭连接 , 在四次挥手时常见 , 请记住

TCP提供**面向有连接**的通信传输 , 运行在传输层上 , 依靠IP协议

> 面向连接(并不是指真实存在的电路连接而是虚拟连接):
>
> 1. 在通信开始前会进行两端的准备工作
> 2. 状态和序列号 ,  错误校验 , 保证了数据的可靠性 .
>
> 也正是因为它面向连接 , 带来了一些除传输数据之外的开销 , 这影响到了传输速度和**延迟**

## **TCP 三次握手 **

> 握手的目的是为了保证 C S 都可以进行正确的收发 !
>
> 这是面试时最常见的一个问题 , 请务必细致的理解它 , 从过程及原理上理解

![img](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)

**第一次握手 : C(客户机) 向 S(服务器) 发送一个 SYN包 (seq = J) , 并进入SYN_SENT状态**

> 需要注意SYN = 1 表明这是一个SYN包 , seq = J (J为一个随机数) ,表示此包的序号为J

**第二次握手 : S 收到SYN包 , 并回复一个 ACK(ack =J+1) , 同时效仿第一次握手 ,发送一个SYN(seq = K)** 

> 本来应该是发送两个包 , 但是因为我们可以将SYN字段 和ACK字段都置为1 , 实现了一个SYN+ACK的效果,这也是三次握手的一个优雅之处.

**第三次握手:C 发送ACK包(ack = K+1)**

> 当第二次完成连接之后 C 已经完成了收发过程 , 进入ESTABLISHED状态
>
> 当 S 收到ACK报文是 , 也进入ESTABLISHED状态 , 两者就进行正常的信息传输了
>
> 请注意因为网络有着比较大的不确定性 , 所以三次握手也是很粗糙的进行了通信准备 , 但是这确实简短而且有效 .

### 为什么要三次握手?两次握手?四次握手?

三次握手恰好可以满足我们验证C S两端的通信 : C的收发 , S 的收发

两次握手不可以 , 因为最多只验证了 C 的收发 , 而S 并不能获得确认响应

四次握手可以 , 但会造成浪费 .原因参见第二次握手的解释.

## **TCP四次挥手**

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

引用自博客 <https://blog.csdn.net/qq_38950316/article/details/81087809>

> 之所以是四次挥手是因为TCP连接是全双工的 , 必须要两端都进行半关闭 , 需要对每一端进行读写关闭

第一次挥手 : C 不在需要发送数据 , 向S 发送 FIN (seq = u)  , 进入FIN_WAIT_1

第二次挥手 : S 向 C 回复ACK(ack = u+1) 并进入关闭等待的状态  , C 收到后进入FIN_WAIT_2状态

> 请注意 : 这时并不意味着连接已经完全关闭了 , 只是表明 C 的发 , 和 S 的 收 处于关闭状态 , 因为S可能有部分数据需要发送 , 所以不会立刻进行下一次半关闭  . 而是等待 S的数据完全关闭之后进行 . 

第三次挥手 : S 向 C发送 FIN( seq = w , ack = u+1) , S进入LAST_ACK 状态

第四次挥手 : C 向 S 发送ACK(seq = u+1 , ack = w+1) , 等待 2MSL的时间 , 如果 S 并未发送重发包 , 关闭

> **为什么要等待2MSL的时间 ?**
>
> 首先 MSL 是 最大报文段生存时间  , 一个报文能够生存的最长时间  . 2*MSL 可以理解为一个发送和回复的最长时间 .
>
> 之所以要等待2MSL是为了防止S没有收到第四次握手而重复发送 第三次握手. 

## TCP的确认.重传.滑动窗口.拥塞控制

> 您可以直接参照 [Cecilia3333](https://blog.csdn.net/Cecilia3333/article/details/80358201?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
>
> 想拿SP ? 请务必重视 ! 

### 确认机制



## UDP

UDP是一种无连接的传输层协议 , 提供不可靠信息传输 , 

1. 发送数据不需要建立连接 
2. 尽最大努力交付 , 但不保证
3. 面向报文

## UDP与TCP的区别

- TCP面向连接(三次握手 , 四次挥手) , UDP面向非连接 . 造成的后果是:
  1. UDP的速度要快于TCP 
  2. UDP使用了更少的系统资源
  3. UDP的程序结构跟更简单
- TCP提供可靠的服务,  UDP无法保证 : 原因是TCP提供 纠错(校验和).查重.确认.重传的功能
- TCP提供的是一对一的服务,UDP可以进行广播和多播
- TCP使用滑动窗口进行流量控制 , 而UDP并没有流量控制的机制

# HTTP部分





