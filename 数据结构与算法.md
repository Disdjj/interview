# **数据结构与算法**

> 主要通过leetcode hot100 进行复习. 后期会增加剑指offer刷题攻略
>
> 答案仅作为参考 .
>
> 多人合作 , 尽量提供多种语言的描述方案 .
>
> 如果您有更好的解法,欢迎提交
>
> ## 按难度从简单到困难进行

## [617.合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

> ### 解决思路
>
> 递归思路:
>
> A.B两棵树 , 如果A不为空且B不为空,新建节点:val值为两者相加. 接着处理(A.left 和 B.left ) 与 (A.right 和 B.right)
>
> 非递归思路:
>
> 考虑使用队列或者栈 , 但不推荐,递归思路更加的简洁清晰,而且基本不会出现爆栈等错误情况

```python
#python代码:   
class Solution:
​    def mergeTrees(self, t1, t2 ) -> TreeNode:
​        if not t1 : return t2
​        if not t2 : return t1
​        res = TreeNode(t1.val + t2.val)
​        res.left = self.mergeTrees(t1.left , t2.left)
​        res.right = self.mergeTrees(t1.right , t2.right)
​        return res
```

## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

> 解决思路:
>
> 需要了解前置知识:  异或(^):相同为0 , 不同为1
>
> 两个数字异或之后,统计结果中1的出现次数.

```python
#python代码
class Solution:
​    def hammingDistance(self, x: int, y: int) -> int:
​        a = x ^ y
​        res = 0
​        while a:
​            res += (a & 1)
​            a >>= 1
​        return res
```

```python
#python代码
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).count('1')
```

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

> 解决思路:
>
> 1.归交换 左子树 , 右子树 :swap(root.left , root.right)
>
> 2.遍历问题可以考虑使用栈或者队列辅助
>
> 在python中有更加简便的方法 : root.left , root.right = root.right , root.left

```python
#python非递归
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        stack = [root]
        while stack :
            ln = len(stack)
            for i in range(ln):
                a = stack.pop()
                if a:
                    a.right , a.left = a.left , a.right
                    stack.append(a.right)
                    stack.append(a.left)
        return root
```

```python
#python递归
class Solution:
    def invertTree(self, root):
        if not root : return root
        root.left , root.right = root.right , root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```